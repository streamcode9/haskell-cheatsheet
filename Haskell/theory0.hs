fix f = f (fix f)
-- f - это коллбек для рекурсивного вызова

sumInt n = fix sum n 0 where ...
-- sum вместо рекурсии использует коллбек, а fix этот коллбек конструирует

-- fix f = let x = f x in x надо читать как "fix - это синоним \f -> let x = f x in x
-- Ну и дальше если ты пишешь
-- fix sum n 0 то у нас идёт замена
-- заменяется последовательно каждый раз leftmost outermost синоним
-- тут самый левый из самых верхних - это fix

-- ((fix sum) n) 0
-- вырожденное дерево
-- (2 + 3) * (3 + 2) вот
-- уже не вырожденное

-- (2 + 3) * (3 + 2) 
           ap
       /       \
      ap        ap
     /   \       /\
    *     ap    ap 2
   /\     /\
  ap 3    + 3
 /\ 
+ 2

-- вот наше дерево :grinning: c какого места его вычислять?
-- джаваскрипт начинает с leftmost innermost, т.е. с (+) 2
-- тут есть понятие редекса - чего-то что можно редуцировать
-- редуцировать = позаменять
-- 2 ты ни на что не заменишь
-- а вот + можно в двух местах и умножение
-- итого у нас 3 редекса, и из них выбираем либо leftmost innermost (в энергичных языках) либо leftmost outermost (в ленивых)
-- Т.е. либо левый + либо умножение
-- Хаскель начинает с умножения
-- На умножении не очень понятно, но у нас есть пример фикса
-- Там есть тонкость что сначала нам надо все определения рассахарить в лямбды

-- У нас есть
fix f = let x = f x in x
sumInt n = fix sum n 0 where
    sum f x acc = case x of
        0 -> acc
        _ -> f (x - 1) (x + acc)
-- что эквивалентно
sumInt = 
  let fix f = let x = f x in x in
  let sum f x acc = (case x of
        0 -> acc
       _ -> f (x - 1) (x + acc))
    in \n -> fix sum n 0
-- первое это сахар для второго а второе тоже сахар

let foo = bar in quux -- это сахар для (\foo -> quux) bar
-- cоответственно надо всё рассахарить
let fix f = let x = f x in x 
-- рассахаривается в
let fix = \f -> (\x -> x) (f x)

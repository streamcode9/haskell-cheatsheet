* update tech stack
* http://paulgraham.com/bel.html
* https://fsharpforfunandprofit.com/
* rust erl ocaml lisp https://semantic.vision/
* http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en
* https://medium.com/@l.mugnaini/the-elm-architecture-tea-animation-3efc555e8faf
* https://hiptest.com/blog/hiptest/getting-started-with-bdd-part-1/
* https://lisp-univ-etc.blogspot.com/

----

* agnostic software engineering
  * bad code = fragility, rigidity, dependencies => interface
  * good code = easy to delete, thin controllers - thick models, zero dependency, dogfooding
* architecture: scalability immutable distributed cross-region systems (logs transactions)
  * [anti]patterns
  * monolith, hexagon architecture [stv -> domain <- repo], crud apps, per feature [folders] structure
  * micro services, pipeline architecture
  * DDD webSocket webRTC
  * azure serviceBus webJob function appInsights keyVault graphApi AD
* js razor chai jasmine scss i18n
* react redux react-scripts testing-library.com
* asp wcf swagger identity-server automapper
  * .net core: memory-management GC multi-threading IQuerable IEnumerable yield serilog autofac regExp
* ef: migration seed fluent-api EntityTypeConfiguration concurrentToken
  * ado.net distributed-transactions
  * sql stores rows: normalization acid execution-plan bulk-ops cqrs, occured deadlocks tbl
  * graphql stores hierarchies
* test: act-arrange-assert, obj.verify(o => o.f(x)).ones(), acept-fb, regression-dev nunit xunit moq specflow
* tools: git bash, tortoise, vs, vs code, nodepad++, fiddler, sql studio, total commander, wireshark, chrome, kdiff, nswagstudio, azure
* clean code metrics: nesting lvl, WTF counter, LOC, dependencies

